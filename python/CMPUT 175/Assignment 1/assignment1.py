# Assignment 1
# Author: Junhyeon Jayden Cho
# References: Stack Overflow, https://stackoverflow.com/


def main():
	# read files into either a list or a dictionary
	products = {i[0]: i[1] for i in initialize("products.txt", ";")}
	suppliers = {i[0]: i[1] for i in initialize("suppliers.txt", ";")}
	availability = initialize("availability.txt", ",")
	# add to the dictionary only if quantity is less than 20
	need_to_be_ordered = {i[0]: i[1] for i in initialize("onshelves.txt", "#") if int(i[1]) < 20}
	
	# assign multiple variables returned by generate_main() function
	list_of_orders, total_cost, highest_suppls = generate_main(need_to_be_ordered, products, availability)
	
	# generate the table using variables generated by other functions
	generate_table(list_of_orders, total_cost, highest_suppls, suppliers)


def initialize(name, separator):
	"""
	Opens the file with name, and separate each line with separator as a list
	Args:
	   name (str): name of the text file
	   separator (str): character that will be used to split the each line of the text file
	   
	Returns:
		str[][]: returns a list that contains a list of each divided line
	"""
	
	list_of_lines = open(name, "r").readlines()
	
	for i in range(len(list_of_lines)):
		list_of_lines[i] = list_of_lines[i].rstrip().split(separator)
	
	return list_of_lines


def find_supp(key, availability):
	"""
	Finds a supplier that has the lowest price for given key
	Args:
		key (str): the given product code
		availability (str[][]): list of prices of products

	Returns:
		a tuple that contains the supplier number that sells the product and its price

	"""
	current_cheapest = [0, 10000.00]
	
	for each_line in availability:  # each_line = [product_code, supplier's phone#, price]
		if each_line[0] == key and float(each_line[2]) < float(current_cheapest[1]):
			current_cheapest = [int(each_line[1]), float(each_line[2])]
	
	return tuple(current_cheapest)


def generate_row(items, char = "|", rules = None, entry = False, lengths = None):
	"""
	Generate a list that contains the item that will go into each column of each line
	Args:
		items (str[]): a list of strings that will go into each column of the row
		char (chr): a character that is used to join each columns of the line
		rules (str[]): rules used to format the string
		entry (bool): a boolean variable used to determine whether function is used to generate normal lines like
		dividers or not. When entry = True, it is used to generate lines of products that are need to be ordered
		lengths (int[]):  collection of length of each column if has different length than main portion of the table

	Returns:
		a list that contains the item that will go into each column of each line
	"""
	if rules is None:  # if rules are not set; this is used for entries (main portion of the table)
		rules = ["^", ">", ">", "^", ">"]
	
	if lengths is None:  # if lengths are not set; this is used for entries (main portion of the table)
		lengths = [14, 18, 8, 16, 10]
	
	result = []
	
	for i in range(len(items)):
		# each column is formed accordingly and appended to the result list
		
		if entry:  # used for entries
			if i == 3:  # 4th column which is phone# of the suppliers
				result.append((" ({0}) {1} {2} ").format(str(items[i])[:3], str(items[i])[3:6], str(items[i])[6:10]))
			
			elif i == 4:  # 5th column which is cost of each lines
				result.append((" ${0:" + rules[i] + "7.2f} ").format(items[i]))
			
			else:  # 1st, 2nd and 3rd column
				truncating_length = (lengths[i] - 1) if "*" in str(items[i]) else (lengths[i] - 2)
				result.append(("{0:" + rules[i] + str(lengths[i] - 1) + "} ").format(str(items[i])[:truncating_length]))
		else:  # for general purposes without truncating such as dividers, names of the columns, etc..
			result.append(("{0:" + rules[i] + str(lengths[i]) + "}").format(str(items[i])[:lengths[i]]))
	
	# joins every item with the character given, and also put the character at the both ends
	return str(char) + str(char).join(result) + str(char)


def generate_main(need_to_be_ordered, products, availability):
	"""
	Generates the main list that contains the lines generated by generate_row() function
	Args:
		need_to_be_ordered (dict): dict of products and its left amount thar are need to be ordered
		products (dict): dict of products with its name
		availability (str[][]): list of product code, supplier's number and its price

	Returns:
		[ a list of lines that will go into the table,
		the total cost of the orders,
		a list of supplier(s) with the highest cost(s) ]
	"""
	result = []
	cost_for_each_suppl = {}
	
	for product_code, current_amount_left in need_to_be_ordered.items():
		quantity = 50 - int(current_amount_left)
		supplier, price = find_supp(product_code, availability)
		cost = round(quantity * float(price), 2)
		if supplier in cost_for_each_suppl:  # if supplier already exists in cost_for_each_sup
			cost_for_each_suppl[supplier] += cost
		else:
			cost_for_each_suppl[supplier] = cost
		
		# items that will go into each column of the lines
		result.append([product_code, ("*" if quantity > 40 else "") + products[product_code], quantity, supplier, cost])
	
	highest_suppls = []  # this will contain only supplier(s) with highest cost
	
	# append to highest_suppls if the value is highest and its key is not in the list yet
	for key, value in cost_for_each_suppl.items():
		value_max = max(cost_for_each_suppl.values())  # calculated highest cost
		if value == value_max and key not in highest_suppls:
			highest_suppls.append([key, value])
	
	# sort the list based on 4th items (suppliers)
	result = sorted(result, key = lambda x: x[3])
	# add all the costs and round it to the second decimal point
	total_cost = round(sum([x[4] for x in result]), 2)
	
	return result, total_cost, highest_suppls


def generate_table(list_of_columns, total_cost, highest_suppliers, suppliers):
	"""
	Create the table list by generating each row using its column items, and write each lines into "orders.txt" file
	Args:
		list_of_columns (str[][]): a list that contains columns to be written into the table
		total_cost (float): a sum of all the costs in the main_list
		highest_suppliers (str[]): a list containing the supplier's number(s) with highest cost(s)
		suppliers (str[][]): list of suppliers' numbers and names of each
		
	Returns:
		None
	"""
	# pre-define the divider for convenience
	divider = generate_row(["-" * 18 for i in range(5)], char = "+")
	column_names = generate_row([" Product code", " Product Name", "Quantity", " Supplier", " Cost"], rules = ["<"] * 5)
	table = [divider, column_names, divider]
	
	# append entries to the table list
	for item in list_of_columns:
		table.append(generate_row(item, entry = True))
	
	# append the total cost part
	table.append(divider)
	table.append(generate_row([" Total Cost", "${0:>10}".format(total_cost)], lengths = [14, 27], rules = ["<", ">"]))
	table.append(generate_row(["-" * 30] * 2, char = "+", lengths = [14, 27]))
	
	# append supplier(s) with highest cost(s)
	for each in highest_suppliers:  # each = [supplier's phone#, its summed-up cost]
		each[0] = str(each[0])
		table.append("Highest cost: {0} ({1}) {2} {3} [${4:.2f}]".format(
			suppliers[each[0]], each[0][:3], each[0][3:6], each[0][6:10], each[1])
		)
	
	# write each items in the table list to "orders.txt"
	open("orders.txt", "w+").writelines("\n".join(table))


main()
